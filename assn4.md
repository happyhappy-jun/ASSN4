

# Assignment #4

이름: 윤병준 

개발환경: 

- Compiler: clang
- IDE: CLion
- Tested in Linux Environment, Visual Studio 2019

학번: 20190766

학과: 무은재학부

담당교수: 윤은영

POVIS ID: junyoon

## Honor code

"나는 이 프로그래밍 과제를 다른 사람의 부적절한 도움 없이 완수하였습니다."

## Problem : 'Dots and boxes' game

### 1.1 문제의 개요

------

이미지파일을 표시하기 위해서는, RGB 세가지 값으로 한 픽셀을 표현해 색깔을 나타낸다. 이 각각의 색로만 이루워져있는 이미지파일의 일부를 채널이라고 한다. 이번 과제에서는 이미지 파일의 채널이 어긋난 파일을 받는다. 이 어긋난 파일에서 RGB데이터를 읽어서 채널의 위치를 다시 맞춰주는 이미지 정합을 하는 프로그램을 만드는 것이다. 

![assn4 SC]()

- 입력부:
  
  - 메뉴: 메뉴에서 사용자로부터 원하는 행동을 선택 받아 작동한다.
    - 이미지 불러오기 또는 변경하기: 이미지 파일이 로드가 되어있지 않으면 새로 불러오기, 이미 로드가 되어있으면 그 파일을 변경하기
    - SSD
    - NCC
    - 종료
  - 파일 입력: 프로그램과 같은 폴더에 확장자를 포함한 파일 길이가 30인 파일을 저장해두고, 프로그램에서 그 파일을 읽어온다.
  
- 처리부: 

  - 메뉴: 메뉴에서 선택한 정합 알고리즘을 사용하여 평가값을 계산한다. 
  - 파일 읽기: 이미지 파일을 읽어와서, 그 크기 만큼의 픽셀 갯수를 동적 할당한다. 
  - 데이터 저장: 정합을 완료한 후에, 줄어든 폭과 넓이를 받아서, 새로운 이미지 구조체에 동적 할당하고 새 RGB값을 쓴다

- 출력부: 

  - 파일 쓰기: 데이터 저장부에서 저장한 이미지 구조체를 읽어서 파일에 쓴다. 

    - ```int sprintf(char* str, const char* format, ...);``` 을 사용하여, 최종 파일 이름을 만든다. 
    - 만든 파일 이름으로 파일을 쓴다. 

  - stdout 

    -  각 채널의 쉬프트와 정합 방법의 이름을 포함한 파일이름으로 내보낸다. 그리고 그 결과를 다음과 같은 포맷으로 출력해준다. 

    ```
    SSD - R:[-9, 14] G:[-7, 15]
    결과 이미지 파일: lena_test_SSD_R-9_14_G-7_15.ppm
    ```

    

### 1.2 알고리즘 

---------

이 프로그램의 구현을 위한 알고리즘을 Pseudo 코드 형태로 나타내면 아래와 같다 

```
include header

int main
	menu
		1: 
			put img name to temp buf
			try to open image, if fail break
			if image is loaded, try to change it and cpy temp to filename, if fail break
		 	else if image read is success stcpy temp to filename
		 	else break
		2 or 3:
			if img is not loaded break
			start clock
			SSD or NCC for Red channel
			SSD or NCC for Green channel
			stop clock
			fill SSDed or NCCed image
			make output filename
			wirte img to outfile
			print result
			free SSDed or NCCed image
```

위의 Psuedo code를 flowchart로 표현한다면 다음과 같다.  출력부의 이름을 출력하는 부분은 알고리즘과 별개이므로 생략했다. 

![assn3_turn_fc]()



### 1.3 프로그램 구조 및 설명

--------------

#### 1.3.1 이미지 변경

이 프로그램에는 이미 이미지가 로딩되어 있을때를 대비해, 이미지 변경 기능이 로딩 메뉴 아래에 있다. 그래서 그것을 위한 if-else statement 처리가 필요했다. 그리고, 메뉴에서 현재 로딩되어있는 이미지 이름을 보여주는데, 존재하지 않는 이름을 입력해 파일 읽기에 실패해도 이 부분의 이미지 이름이 바뀐다. 그래서 ```temp``` 변수를 추가해 파일이름 입력을 ```temp``` 로 받고, 파일 읽기에 성공한 브렌치에서만 ```temp``` 를  ```filename```로 복사하였다. 

#### 1.3.2 이미지 구조체

이번 어싸인부터 ```typedef``` , ```struct``` 등의 제한이 풀리면서, 좀 더 편안하게 코딩할 수 있게 되었다. 이 프로그램에서는 이미지를 다루는 프로그램이다보니, 다음과 같은 구조체를 사용하였다. 

- 픽셀 타입
  - ```unsigned int``` *3 -> RGB 

- 이미지 타입
  - 폭, 높이
  - 픽셀 포인터
- 이미지 포인터 타입
  - ```typedef image_t *image; ```
- 쉬프트 타입
  - x축 이동, y축 이동
  - 평가값

이미지 포인터 타입을 사용하면서 ```->``` 연산자를 사용해, 함수의 매개변수로 받은 구조체의 내용을은 주소값으로 엑세스해 변경할 수 있게 하였다. 픽셀은 크키가 3인 배열이고, 이미지 타입의 픽셀 포인터는 폭과 높이를 사용해 크키가 3인 메모리를 픽셀의 수만큼 동적할당 받아 픽셀수*3크기의 2차원 배열을 만들었다. 

#### 1.3.3 이미지 읽기 

이미지 파일은 raw text포맷으로 읽을수 있으므로, 읽기 모드는 read mode 로 파일을 연다. 파일 헤더에는 파일 타입, 폭, 크키, 깊이가 적혀있다. ``` P3 Width Height depth``` 의 형태로 젹혀져 있으므로 이 포맷에 맞춰서 ```%c%d %u %u %u\n``` 을 fscanf 로 읽으면 된다. 

#### 1.3.4 이미지 쓰기

이미지 쓰기는 총 두단계로 나뉜다. 

-  이미지 구조체 채우기
  - 원본 이미지, 각 채널의 쉬프트 값을 가지고 새로운 이미지 타입을 채워 넣는다. 최종 높이와 폭을 계산해서 동적할당을 해주고, 쉬프트한 값을 원본이미지에서 찾아서, 새로운 이미지 구조체에 넣어준다. 그 후, 완성된 이미지 구조체 포인터를 리턴한다. 
-  파일에 쓰기
   - ```writePPM(image img, const char *filename)```이 함수가 첫번째 스텝에서 리턴한 이미지 구조체를 받아, 파일에 쓴다. 일단 새로운 폭과 높이로 파일 헤더를 작성한다. ```Pixel```자료형은 정수 3개로 이루워진 구조체 이므로, ```img->data[i][0]``` 이런식으로 Red 채널에 엑세스 할 수 있다. 이렇게 픽셀 갯수만큼 반복문을 돌리면서 각 픽셀에서 RGB값을 뽑아서, 새 파일에 쓴다. 

#### 1.3.5 SSD (Standarized Square)

이 SSD방법은 평가값이 작을 수록 좋은 값이다. 따라서, 처음 쉬프트 타입의 초기화를 INT_MAX







### 1.6 토론 및 결론

- 2차원 배열의 사용법을 익혔다. 
- 애초에 트리라는 것이 구조체가 없으면 못 만드는 것으로 알고 있었는데, 구조체를 사용못하는 제약 조건 속에서 머리를 짜내다 보니까, 재귀라는 아이디어가 떠올랐다. 제한 조건하에서의 의외의 발전이 있었다. 
- 이번부터 어싸인하는데 있어서 패턴에 변화를 두었는데, Think Once, Code Twice 가 아니라 Think Twice, Code once로 바꿔서 종이에 손코딩을 한 후에 직접 코딩을 하니까 프로그램의 구조가 훨씬 이쁘게 나오는 것을 느꼈다. 
- 제약 조건을 걸어서 더 많이 생각했던것 같고, 코드를 짠게 아니고 프로그래밍이 뭔지 배우는 거 같은 느낌이 자주 어싸인 하면서 든다. 
- 이론상 민맥스 알고리즘은 깊이가 깊어질수록 승률이 올라가야한다. 하지만 게임의 특수성 때문인지 아닌지는 모르겠지만, 너무 깊은 깊이는 오히려 승률을 많이 낮춰서 적당한 값을 정해야한다. 이 문제에 대해서는 구조체로 다시 짜고 결과를 봐야 겠다. 


